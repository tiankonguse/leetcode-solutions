## 背景

最近两周在看书，看完了两本书《腾讯传》和《白鹿原》，然后算法分享就延后了。  
这周规划一下自己的时间，尽量合理分配。  

这里分享一下一周前在小密圈分享的一道回文串的题。  
对于算法题，我的建议是自己实现一下。
不然到后面面对大项目或者复杂算法题的时候，你会发现这些基础算法也是需要很多技巧的。  

分享的算法题，一般是英文题，这是由于标准的ACM比赛的题目都是英文题。  


## 题意



告诉你一个大整数，求离这个数最近的回文数（不包含自身）。  

然后有两个提示。

> 
> 当最近的回文数存在多个时，取最小的回文数。  
> 输入的大整数位数不超过18位。  
> 


## 边界

1. 个位数都算回文数  
2. 部分数字的长度和答案的长度可能不同。（10的幂数）  
3. 最近回文数有多个时，取最小的那个。  


## 算法思路  


1. 拆解：先得到小于该数字的最大回文串和大于该数字的最小回文串。  
2. 转化：拆解1 - 小于该数字的最大回文串等价于小于等于该数字减一的最大回文串。  
3. 贪心1：拆解1 - 回文是对称的，所以只看高位。贪心规则：我们必须先确定第x位的值后，才能去确定第x-1位的值。
3. 贪心2：拆解1 - 假设某位为数字'a'有解，则该位为['0','a'-1]的解都不没有'a'更优，故每一位从'9'到'0'迭代。  
4. 同理：对于拆解2，和拆解1相反的做法。  
5. 合并：两个局部最优解和当前数字求差值，差值小的为最优解。  

## 数学思路


1. 拆解：先得到小于该数字的最大回文串和大于该数字的最小回文串 - O(1) 
2. 转化：拆解1 - 小于该数字的最大回文串等价于小于等于该数字减一的最大回文串 - O(1)
3. 边界：拆解1 - 保证后续大于一位数且答案的位数不变 O(1)
4. 判断：拆解1 - 字符串高位对称覆盖低位是否可行，不可行则减1，肯定可行，且减少的最少，即值最大。 O(1)
5. 同理：对于拆解2，和拆解1相反的做法。  
6. 合并：两个局部最优解和当前数字求差值，差值小的为最优解。

判断 拆解1举例：

例1：输入 123454322，高位覆盖低位可行，于是答案是 123454321。
例2：输入 123454320，高位覆盖低位可行，于是高位减1，答案是 123444321。
例3：输入 120000011，高位覆盖低位可行，于是高位减1，答案是 119999911。

## 本质

对于数学思路， 能够发现高半部变化的值越小，最终答案的变化也就越小。
所以本质是高半部加一减一问题了。
其实只要没有位数不一致这个问题， 其他的都好办。 所以我对位数不一致特殊处理就简单多了


## 代码

见[github](https://github.com/tiankonguse/leetcode-solutions/tree/master/problemset/find-the-closest-palindrome)

