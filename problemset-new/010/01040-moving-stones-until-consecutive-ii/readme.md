# 1040. 移动石子直到连续 II

在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。

每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。

值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。

当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。

要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。

 

示例 1：

输入：[7,4,9]
输出：[1,2]
解释：
我们可以移动一次，4 -> 8，游戏结束。
或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
示例 2：

输入：[6,5,4,3,10]
输出：[2,3]
解释：
我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
示例 3：

输入：[100,101,104,102,103]
输出：[0,0]
 

提示：

3 <= stones.length <= 10^4
1 <= stones[i] <= 10^9
stones[i] 的值各不相同。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/moving-stones-until-consecutive-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


## 1040. Moving Stones Until Consecutive II


题意：给一些互不相同的数字，每次可以将最大的数字或者最小的数字进行修改。修改后这个值不能是最大值和最小值。  
最终不能移动时，结束。  
求移动的最大步数和最小步数。  


思路：对于最大步数，肯定是最好一步步的移动。  
由于规则的限制，第一次移动可能不是一步，而是很多步，之后可以一步步移动。  
所以第一次移动时，选择步数最小的（最大值和最小值两个数字选一个），之后就是有多少个空位置，就可以移到多少次。  


而对于最小步数，则是尽可能所有数字只移动一次。
做题的时候，我的思路是暴利枚举。  
假设数字最终区间确定，那么移动的最小步数也是确定的。  
枚举所有可能的区间，然后计算最小步数。  


这道题最优答案是贪心计算。  
假设找到了最长的连续数字，则其他数字都应该移到到这个最大的连续数字附近。  
需要移动的步数就是不是最长连续数字的个数。  
但是有一个特殊情况：连续数字是`n-1`个且最小值或最大值不是连续数字，此时需要两步，而不是一步。


## C++  


[tiankonguse.cpp](./tiankonguse.cpp)





