## 719. Find K-th Smallest Pair Distance
# 719. 找出第 K 小的数对距离

题意：给定一个整数数组，返回所有数对之间的第 k 个最小距离。  
一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。  





```
输入：nums = [1,3,1] k = 1
输出：0 
解释：
所有数对如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
```

因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。


思路：这道题需要先根据样例输入来理解题意。  
n个数字，大概会有`C(n,2)`种差值，求最第k小的差值。  


起初看到这道题，我是没有思路的。  
想到这道题属于二分专题，我就有思路了。  


既然是寻找第k小的差值，我们可以二分差值，判断是否满足有k个。  


预先对数组排序，则差值可以划分为`n-1`组。  


```
(1,2) (1,3) (1,4) ... (1,n)
      (2,3) (2,4) ... (2,n)
	        (3,4) ... (3,n)
			      ...
			(n-2,n) (n-1,n)
				    (n-1,n)
```


对于每组差值，从左到右是递增的。  
所以可以二分判断每组有多少个差值满足要求。  
这样就可以求出所有满足差值的个数。  

总体复杂度`O(n * log(n) * log(n))`  



另一种思路：

原始问题是可以转换为在*n*个有序数组中求第*k*大问题，这样就能通过上面的思路解决，不过关于该问题计数这部分，是可以优化的。

设排序后的数组表示为A[1…n]，针对某个数guess，假设以第*i*个元素开头满足小于等于guess的子数组为A[i…j]，那么对第*i+1*个元素来说，A[i+1…j]这部分必然是满足小于等于guess，也就是说对于以i+1开头满足小于等于guess的个数只用从上一轮的不满足条件点继续比较即可，这样就能做到在O(N)的时间复杂度内完成计数。

所以最终整体的时间复杂度为O(n * log(n) + n * log(s))，其中s表示距离对的值域范围。


## C++语言  


[tiankonguse.cpp](./tainkonguse.cpp)

## Python语言

[marvelous.py](./marvelous.py)


数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。

给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 <= i < j < nums.length 。返回 所有数对距离中 第 k 小的数对距离。

 

示例 1：

输入：nums = [1,3,1], k = 1
输出：0
解释：数对和对应的距离如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
距离第 1 小的数对是 (1,1) ，距离为 0 。
示例 2：

输入：nums = [1,1,1], k = 2
输出：0
示例 3：

输入：nums = [1,6,1], k = 3
输出：5
 

提示：

n == nums.length
2 <= n <= 104
0 <= nums[i] <= 106
1 <= k <= n * (n - 1) / 2

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/find-k-th-smallest-pair-distance
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。