## Разностный массив; прибавление констант, арифметических прогрессий и квадратичных функций на отрезке
差异数组；在线段上添加常数、算术级数和二次函数

https://codeforces.com/edu/course/3/lesson/10/4


Мы уже научились по массиву строить его массив префиксных сумм. А теперь давате научимся по массиву префиксных сумм строить исходный массив, то есть применять обратную операцию.
我们已经学习了如何从数组构造前缀和数组。现在让我们学习如何从前缀和数组构造原始数组，即应用逆运算。
Определение 定义

Разностным массивом массива [𝑏0,𝑏1,…,𝑏𝑛−1]
 называется массив [𝑎0,𝑎1,…,𝑎𝑛−2]
, определяющийся следующим образом:
数组差值数组 [𝑏0,𝑏1,…,𝑏𝑛−1]
 称为数组 [𝑎0,𝑎1,…,𝑎𝑛−2]
 ，定义如下：

𝑎0=𝑏1−𝑏0

𝑎1=𝑏2−𝑏1

𝑎2=𝑏3−𝑏2

…

𝑎𝑛−3=𝑏𝑛−2−𝑏𝑛−3

𝑎𝑛−2=𝑏𝑛−1−𝑏𝑛−2

Очевидно, что если 𝑏
 — массив префиксных сумм массива 𝑎
, то массив 𝑎
 — разностный массив массива 𝑏
, потому что формула 𝑎𝑖=𝑏𝑖+1−𝑏𝑖
 — это просто преобразованная рекуррентная формула для поиска префиксных сумм: 𝑏𝑖+1=𝑏𝑖+𝑎𝑖
. Однако разностный массив может помочь нам даже там, где массивом префиксных сумм и не пахнет!
显然，如果 𝑏
 - 数组的前缀和数组 𝑎
 ，然后是数组 𝑎
 - 数组差异数组 𝑏
 ，因为公式 𝑎𝑖=𝑏𝑖+1−𝑏𝑖
 只是一个转换后的递归公式，用于查找前缀和： 𝑏𝑖+1=𝑏𝑖+𝑎𝑖
 。然而，即使前缀和数组不起作用，差异数组也可以帮助我们！
Также обратите внимание, что если для подсчета массива префиксных сумм была нужна рекуррентная формула, то каждый член разностного массива зависит всего от двух элементов исходного, так что можно пользоваться формулами из определения для подсчета разностного массива за 𝑂(𝑛)
.
另请注意，如果需要循环公式来计算前缀和数组，则差异数组的每个成员仅依赖于原始数组的两个元素，因此您可以使用定义中的公式来计算差异数组 𝑂(𝑛)
 。

```cpp
vector<int> findDiffsArray(vector<int>& arr) {
    int n = arr.size();
    vector<int> diffs(n - 1);
    for (int i = 0; i < n - 1; i++) {
        diffs[i] = arr[i + 1] - arr[i];
    }
    return diffs;
}
```


Если вы знакомы с основами матанализа, можно заметить, что переход к разностному массиву — это дискретное дифференцирование, а переход к массиву префиксных сумм — дискретное интегрирование.
如果您熟悉数学分析的基础知识，您会注意到到差异数组的转换是离散微分，而到前缀和数组的转换是离散积分。

Применения разностного массива
差分数组的应用

Решим несколько задач, используя разностный массив. Мы уже решили задачу нахождения суммы на отрезке при помощи префиксных сумм, а теперь рассмотрив в некотором смысле обратную задачу: задачу о прибавлении на отрезке.
让我们使用差分数组来解决几个问题。我们已经解决了使用前缀和在区间上求和的问题，现在我们在某种意义上考虑了逆问题：区间上的加法问题。

Задача 任务

Дан массив длины 𝑛
. Приходят 𝑞
 запросов: прибавить на полуинтервале [𝑙,𝑟)
 ко всем элементам число 𝑑
. После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика 𝑂(𝑛+𝑞)
.
给定一个长度的数组 𝑛
 。他们来了 𝑞
 查询：添加半间隔 [𝑙,𝑟)
 所有元素的编号 𝑑
 。执行完所有查询后，您需要输出结果数组。渐近学 𝑂(𝑛+𝑞)
 。

Решение 解决方案

Ранее мы говорили о том, что если элементы массива меняются, то для решения задачи понадобятся продвинутые структуры, такие как дерево отрезков или дерево Фенвика.
前面我们说过，如果数组的元素发生变化，那么就需要线段树或芬威克树等高级结构来解决问题。
Однако здесь мы обойдемся без них, потому что у нас есть только запросы изменения, а запрос «получения» есть только один в самом конце.
然而，我们在这里不需要它们，因为我们只有更改请求，并且最后只有一个“获取”请求。

Давайте в начало исходного массива 𝑏
 допишем фиктивный элемент ноль и у получившегося массива возьмем разностный массив 𝑎
. После чего будем наблюдать за тем, как этот массив 𝑎
 будет меняться в следствии запросов изменения массива 𝑏
 на отрезке. Фиктивный ноль мы добавили для того, чтобы не потерять информацию о нулевом элементе массива 𝑏
, ведь только по разностям соседних элементов восстановить исходный массив не получится.
让我们转到原始数组的开头 𝑏
 添加一个虚构元素零并从结果数组中取出一个差异数组 𝑎
 。之后我们将观察这个数组如何 𝑎
 将由于阵列更改请求而更改 𝑏
 在该段上。我们添加了一个虚构的零，以免丢失有关数组零元素的信息 𝑏
 ，因为仅通过相邻元素的差异不可能恢复原始数组。

Пускай на полуинтервале [𝑙,𝑟)
 исходного массива (или на полуинтервале [𝑙+1,𝑟+1)
 массива с фиктивным нулем в начале) прибавили ко всем элементам 𝑑
. Заметим, что элементы массива 𝑎
 на позициях меньших 𝑙
 и больших 𝑟
 никак не поменяются, потому что оба элемента в разности никак не поменялись. На позициях 𝑙+1,…,𝑟−1
 тоже ничего не поменяется, потому что к обоим элементам разности прибавят 𝑑
, в результате чего сама разность не изменится. К примеру, для позиции 𝑙+1
:
让它以半个间隔 [𝑙,𝑟)
 源数组（或半间隔 [𝑙+1,𝑟+1)
 带有虚拟前导零的数组）添加到所有元素 𝑑
 。注意数组元素 𝑎
 在较小的位置 𝑙
 和大 𝑟
 不会以任何方式改变，因为差异中的两个元素都没有以任何方式改变。关于职位 𝑙+1,…,𝑟−1
 也不会发生任何变化，因为差异将添加到两个元素中 𝑑
 ，因此差异本身不会改变。例如，对于职位 𝑙+1
 :

𝑏𝑛𝑒𝑤𝑙+1−𝑏𝑛𝑒𝑤𝑙=(𝑏𝑜𝑙𝑑𝑙+1+𝑑)−(𝑏𝑜𝑙𝑑𝑙+𝑑)=𝑏𝑜𝑙𝑑𝑙+1+𝑑−𝑏𝑜𝑙𝑑𝑙−𝑑=𝑏𝑜𝑙𝑑𝑙+1−𝑏𝑜𝑙𝑑𝑙

Таким образом, после операции прибавления на отрезке изменятся только два элемента разностного массива: 𝑎𝑙
 заменится на 𝑎𝑙+𝑑
, и 𝑎𝑟
 заменится на 𝑎𝑟−𝑑
.
因此，在对段进行加法操作之后，差异数组中只有两个元素会发生变化： 𝑎𝑙
 将被替换为 𝑎𝑙+𝑑
 ， 和 𝑎𝑟
 将被替换为 𝑎𝑟−𝑑
 。

Алгоритм получается следующий: изначально перейдем от исходного массива к его разностному массиву, предварительно добавив в начало массива 0
, чтобы не потерять информацию о 𝑏0
. Затем выполняем операции изменения за 𝑂(1)
 каждую, потому что нужно поменять каждый раз всего два элемента. И в конце нужно вернуться к исходному виду массива, посчитав префиксные суммы.
该算法如下：首先，我们从原始数组移动到其差异数组，之前已将其添加到数组的开头 0
 以免丢失有关信息 𝑏0
 。然后我们执行更改操作 𝑂(1)
 每个，因为每次只需要更改两个元素。最后，您需要通过计算前缀和来返回数组的原始形式。


```cpp
vector<int> precalc(vector<int> b) {
    b.insert(b.begin(), 0); // add leading zero
    vector<int> a = findDiffsArray(b);
    return a;
}

void addOnHalfInterval(int l, int r, int d) { // [l, r) += d
    a[l] += d;
    if (r < n) {
        a[r] -= d;
    }
}

vector<int> postcalc(vector<int>& a) {
    vector<int> finalB = findPrefixSums(a);
    finalB.erase(finalB.begin()); // delete leading zero
    return finalB;
}
```


Обратите внимание на то, что если 𝑟=𝑛
, то такого элемента нет в массиве 𝑎
, ведь этот элемент отвечал бы за разность элемента после конца массива 𝑏
 с последним элементом массива 𝑏
, которая нас не интересует. Поэтому в таком случае мы ничего не делаем.
请注意，如果 𝑟=𝑛
 ，则数组中不存在该元素 𝑎
 ，因为该元素将负责数组末尾之后元素的差异 𝑏
 与数组的最后一个元素 𝑏
 ，这对我们不感兴趣。因此，在这种情况下我们什么都不做。

На самом деле можно было даже не брать разностный массив.
事实上，你甚至不必采用差异数组。
Можно было считать, что изначально массив состоял из всех нулей, тогда его разностный массив тоже состоит из всех нулей; на этом массиве произвести все операции, посчитать массив префиксных сумм и уже в самом конце прибавить начальные значения элементов массива.
我们可以假设最初数组由全零组成，那么它的差异数组也由全零组成；对该数组执行所有操作，计算前缀和数组，并在最后添加数组元素的初始值。

Задача 任务

Дан массив длины 𝑛
. Приходят 𝑞
 запросов: прибавить на полуинтервале [𝑙,𝑟)
 арифметическую програссию с шагом 𝑠𝑡𝑒𝑝
, то есть к элементу на позиции 𝑙
 прибавить 𝑠𝑡𝑒𝑝
, к элементу на позиции 𝑙+1
 прибавить 2⋅𝑠𝑡𝑒𝑝
, к элементу на позиции 𝑙+2
 прибавить 3⋅𝑠𝑡𝑒𝑝
, ..., и наконец к элементу на позиции 𝑟−1
 прибавить (𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
.
给定一个长度的数组 𝑛
 。他们来了 𝑞
 查询：添加半间隔 [𝑙,𝑟)
 带步骤的算术级数 𝑠𝑡𝑒𝑝
 ，即到位置处的元素 𝑙
 添加 𝑠𝑡𝑒𝑝
 , 到位置处的元素 𝑙+1
 添加 2⋅𝑠𝑡𝑒𝑝
 , 到位置处的元素 𝑙+2
 添加 3⋅𝑠𝑡𝑒𝑝
 , ..., 最后到位置处的元素 𝑟−1
 添加 (𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
 。

После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика 𝑂(𝑛+𝑞)
.
执行完所有查询后，您需要输出结果数组。渐近学 𝑂(𝑛+𝑞)
 。

Решение 解决方案

Задача похожа на предыдущую, но явно сложнее, ведь к каждому элементу на отрезке прибавляется разное число. Давайте посмотрим, что произойдет, если мы как и раньше перейдем к разностному массиву. Заметим, что если мы на полуинтервале прибавили 𝑠𝑡𝑒𝑝,2⋅𝑠𝑡𝑒𝑝,…,(𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
, то в разностном массиве мы на некотором полуинтервале прибавим ко всем элементам 𝑠𝑡𝑒𝑝
, а также из элемента на правой границе вычтется (𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
. Но ведь прибавлять число на отрезке мы уже умеем! Давайте перейдем к разностному массиву разностного массива, при этом не забыв в таком случае добавить уже не один, а два фиктивных нуля в начало массива.
该问题与前一个问题类似，但显然更困难，因为段上的每个元素都添加了不同的数字。让我们看看如果我们像以前一样访问差异数组会发生什么。请注意，如果我们以半间隔添加 𝑠𝑡𝑒𝑝,2⋅𝑠𝑡𝑒𝑝,…,(𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
 ，然后在差异数组中，我们将添加到某个半间隔上的所有元素 𝑠𝑡𝑒𝑝
 ，并且也会从右边框上的元素中减去 (𝑟−𝑙)⋅𝑠𝑡𝑒𝑝
 。但我们已经知道如何在线段上添加数字！让我们继续讨论差异数组的差异数组，在这种情况下不要忘记在数组的开头添加两个虚拟的零，而不是一个。
Тогда для разностного массива разностного массива изменятся только элементы на позициях 𝑙
, 𝑟
 и 𝑟+1
, так что мы можем выполнять все операции за 𝑂(1)
, а затем в конце дважды насчитать массив префиксных сумм, вернувшись к исходному массиву.
那么对于差分数组的差分数组，只有位置上的元素会发生变化 𝑙
 , 𝑟
 和 𝑟+1
 ，所以我们可以执行所有操作 𝑂(1)
 ，然后最后对前缀数组进行两次求和，返回原始数组。


```cpp
vector<int> precalc(vector<int> b) {
    b.insert(b.begin(), 0);
    b.insert(b.begin(), 0); // add two leading zeros
    vector<int> a = findDiffsArray(findDiffsArray(b));
    return a;
}

// [l, r) += [step, 2 * step, ..., (r - l) * step]
void addArithmOnHalfInterval(int l, int r, int step) {
    a[l] += step;
    if (r < n) {
        a[r] -= (r - l + 1) * step;
    }
    if (r + 1 < n) {
        a[r + 1] += (r - l) * step;
    }
}

vector<int> postcalc(vector<int>& a) {
    vector<int> finalB = findPrefixSums(findPrefixSums(a));
    finalB.erase(finalB.begin());
    finalB.erase(finalB.begin()); // delete leading zeros
    return finalB;
}
```


Упражнение 锻炼

Попробуйте решить последнюю задачу, если первый член арифметической прогрессии не совпадает с шагом, то есть на полуинтервале прибавляются числа 𝑠𝑡𝑎𝑟𝑡,𝑠𝑡𝑎𝑟𝑡+𝑠𝑡𝑒𝑝,𝑠𝑡𝑎𝑟𝑡+2⋅𝑠𝑡𝑒𝑝,…,𝑠𝑡𝑎𝑟𝑡+(𝑟−𝑙−1)⋅𝑠𝑡𝑒𝑝
.
如果等差数列的第一项与步骤不重合，即在半区间上添加数字，请尝试解决最后一题 𝑠𝑡𝑎𝑟𝑡,𝑠𝑡𝑎𝑟𝑡+𝑠𝑡𝑒𝑝,𝑠𝑡𝑎𝑟𝑡+2⋅𝑠𝑡𝑒𝑝,…,𝑠𝑡𝑎𝑟𝑡+(𝑟−𝑙−1)⋅𝑠𝑡𝑒𝑝
 。

Упражнение 锻炼

Как обобщить решение прошлой задачи на случай, когда на отрезке прибавляется не линейная, а квадратичная функция? То есть прибавляются числа 𝑠𝑡𝑒𝑝,4⋅𝑠𝑡𝑒𝑝,9⋅𝑠𝑡𝑒𝑝,…,(𝑟−𝑙)2⋅𝑠𝑡𝑒𝑝
.
如何将上一个问题的解决方案推广到当不是线性函数而是向线段添加二次函数时的情况？也就是数字相加 𝑠𝑡𝑒𝑝,4⋅𝑠𝑡𝑒𝑝,9⋅𝑠𝑡𝑒𝑝,…,(𝑟−𝑙)2⋅𝑠𝑡𝑒𝑝
 。

Упражнение 锻炼

Представьте, что у вас есть список операций виде «прибавить на полуинтервале [𝑙,𝑟)
 значение 𝑑
». Но вам нужно выполнять не эти операции, а целые отрезки операций! То есть в действительности операция имеет вид «примените к массиву операции с номерами от 𝐿
-й до 𝑅
-й». В конце нужно вывести получивщийся массив. Как решать такую задачу за 𝑂(𝑛+𝑞)
?
想象一下，您有一个形式为“加半间隔”的操作列表 [𝑙,𝑟)
 意义 𝑑
 ”但您需要执行的不是这些操作，而是整个操作段！也就是说，实际上该运算的形式是“对来自的数字进行运算” 𝐿
 到 𝑅
 -th”。最后您需要输出结果数组。如何解决这样的问题 𝑂(𝑛+𝑞)
 ？

Замечание 评论

Если вы знаете основы матанализа, можно легко понять, почему мы производили именно такие манипуляции. Ведь если взять производную, то прибавление константы на отрезке превратится в прибавление тождественного нуля, а для линейной функции нужно взять вторую производную.
如果您了解数学分析的基础知识，您就可以轻松理解为什么我们要执行此类操作。毕竟，如果你求导数，那么在一段上添加一个常数将变成添加一个相同的零，而对于线性函数，你需要求二阶导数。

Двумерный разностный массив
二维差分数组

Задача 任务

Дан двумерный массив размера 𝑛×𝑚
, изначально состоящий из всех нулей. Приходит 𝑞
 запросов прибавления константы на прямоугольнике. В конце нужно вывести элементы получившегося массива.
给定一个大小为的二维数组 𝑛×𝑚
 ，最初由全零组成。来了 𝑞
 请求在矩形上添加常量。最后，您需要输出结果数组的元素。

Решение 解决方案

Это двумерная версия задачи, которую мы рассматривали ранее, но для простоты изначальный массив состоит из нулей, поэтому нам не нужно переходить к разностному массиву. Надо подумать, к каким элементам что надо прибавить на разностном массиве, чтобы на исходном массиве прибавить 𝑑
 на полупрямоугольнике [𝑙𝑥,𝑟𝑥)×[𝑙𝑦,𝑟𝑦)
.
这是我们之前看到的问题的二维版本，但为了简单起见，原始数组全为零，因此我们不需要使用差异数组。您需要考虑应该将哪些元素添加到差异数组上，以便添加到原始数组上 𝑑
 在半矩形上 [𝑙𝑥,𝑟𝑥)×[𝑙𝑦,𝑟𝑦)
 。

Можно заметить, что если в разностном массиве к какому-то элементу прибавить 𝑑
, то в исходном массиве 𝑑
 прибавится ко всем элементам на суффиксном подпрямоугольнике.
您可以注意到，如果在差异数组中添加某个元素 𝑑
 ，然后在原始数组中 𝑑
 将被添加到后缀子矩形上的所有元素。



Теперь перед нами стоит задача «прибавить на подпрямоугольнике через прибавления на суффиксных подпрямоугольниках». Эта задача аналогична задаче поиска суммы на подпрямоугольнике.
现在我们面临着“通过添加后缀子矩形来添加子矩形”的任务。这个问题类似于在子矩形上求和的问题。



Прибавляем мы к тем же самым клеткам, сумму которых мы брали в задаче поиска суммы на подпрямоугольнике.
我们将与我们在子矩形上求和的问题中采用的总和相同的单元格相加。

В конце мы возьмем префиксные суммы получившегося двумерного массива, и это и будет ответом.
最后我们将得到的二维数组的前缀和相加，这就是答案。

// [lx, rx) * [ly, ry) += d
void addOnHalfRectangle (int lx, int ly, int rx, int ry, int d) {
    diffs[lx][ly] += d;
    if (ry < m) {
        diffs[lx][ry] -= d;
    }
    if (rx < n) {
        diffs[rx][ly] -= d;
    }
    if (rx < n && ry < m) {
        diffs[rx][ry] += d;
    }
}

vector<vector<int>> postcalc(vector<vector<int>>& diffs) {
    vector<vector<int>> finalArr = findPrefixSums2D(diffs);
    finalArr.erase(finalArr.begin());
    // delete leading horizontal zeros
    for (size_t i = 0; i < finalArr.size(); i++) {
        finalArr[i].erase(finalArr[i].begin());
        // delete leading vertical zeros
    }
    return finalArr;
}
Замечание 评论

Как и раньше, мы добавляем нули в начало. В случае двумерного массива мы добавили строку и столбец нулей. В качестве упражнения остается проверить, что индексы, к которым надо прибавлять, будут именно такие.
和以前一样，我们在开头添加零。对于二维数组，我们添加了一行和一列的零。作为练习，仍然需要检查我们需要添加的索引是否完全相同。
При этом как и в одномерном случае, правые индексы могут не существовать в массиве diffs, если они равны высоте или ширине изначального массива.
在这种情况下，与一维情况一样，如果正确的索引等于原始数组的高度或宽度，则 diffs 数组中可能不存在它们。

Упражнение 锻炼

Спросите себя: понимаете ли вы, что делать, если изначально массив состоит не из нулей?
问问自己：如果数组最初不包含零，您知道该怎么办吗？

Упражнение 锻炼

Как обобщить решение предыдущей задачи, если массив уже не двумерный, а трехмерный, и прибавлять надо на параллелепипеде?
如果数组不再是二维的，而是三维的，并且需要添加一个平行六面体，如何推广上一个问题的解决方案？

Определение 定义

Строго говоря, разностный двумерный массив можно строить так же, как и одномерный. Формула для его элементов будет такая:
严格来说，二维差分数组的构造方法与一维差分数组相同。其元素的公式如下：

𝑎𝑖+1,𝑗+1=𝑏𝑖+1,𝑗+1−𝑏𝑖,𝑗+1−𝑏𝑖+1,𝑗+𝑏𝑖,𝑗
что похоже на аналогичную формулу для двумерных префиксных сумм. Но как вы видели, на практике нам не надо изначально строить разностный массив. Нужно просто изначально считать, что он заполнен нулями, а после выполнения операций по нему посчитать массив префиксных сумм.
这类似于二维前缀和的类似公式。但正如您所看到的，实际上我们不需要最初构建差异数组。您只需要最初假设它用零填充，然后对其执行操作后，计算前缀和数组。
И начальные элементы добавить уже в самом конце.
并在最后添加初始元素。