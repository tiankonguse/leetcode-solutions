# Поиск суммы на отрезке и обобщение для других операций
求一个段上的总和并推广到其他操作

https://codeforces.com/edu/course/3/lesson/10/2


Давайте сразу же применим префиксные суммы на примере задачи.
让我们立即将前缀和应用于示例问题。
Задача: поиск суммы на отрезке
任务：求一条线段的和

Дан массив целых чисел, и приходят запросы вида «найти сумму на полуинтервале с позиции 𝑙
 до позиции 𝑟
». Нужно отвечать на запросы за 𝑂(1)
.
给出了一个整数数组，请求就像“求从位置开始的半个间隔上的总和” 𝑙
 定位 𝑟
 ”需要解答疑问 𝑂(1)
 。

Решение 解决方案

Давайте изначально перед ответами на запросы предпосчитаем массив префиксных сумм. Тогда если бы во всех запросах 𝑙
 было равно нулю, то ответом на запрос была бы просто префиксная сумма 𝑏𝑟
.
在回答查询之前，我们首先选择一组前缀和。那么如果在所有请求中 𝑙
 等于零，那么对查询的响应将只是前缀和 𝑏𝑟
 。

Но как же действовать, если 𝑙≠0
? В префиксной сумме 𝑏𝑟
 содержатся все нужные нам элементы, однако есть еще лишние: 𝑎0,𝑎1,…,𝑎𝑙−1
. Но ведь сумма этих элементов — это как раз таки 𝑏𝑙
. Таким образом, выполнено тождество:
但如果 𝑙≠0
 ？前缀金额 𝑏𝑟
 包含我们需要的所有元素，但还有额外的元素： 𝑎0,𝑎1,…,𝑎𝑙−1
 。但这些元素的总和就是这样 𝑏𝑙
 。因此，恒等式成立：

𝑎𝑙+𝑎𝑙+1+…+𝑎𝑟−1=𝑏𝑟−𝑏𝑙

То есть для ответа на запрос поиска суммы на полуинтервале нужно просто вычесть друг из друга две предпосчитанные префиксные суммы.
也就是说，要回答在半间隔上求和的请求，您只需将两个首选前缀和相减即可。


```cpp
int getSum(int left, int right) { // [left, right)
    return b[right] - b[left];
}
```


Обратите внимание на то, какие красивые формулы у нас получаются: сумма на полуинтервале [𝑙,𝑟)
 — это 𝑏𝑟−𝑏𝑙
. Такая красота достигается именно благодаря тому, что мы используем полуинтервалы: и запросы у нас даны в виде полуинтервалов, и префиксные суммы. Если бы префиксные суммы были посчитаны в виде 𝑏𝑖=𝑎0+𝑎1+…+𝑎𝑖
, то в формуле появились бы неприятные ±1
, в которых легко запутаться: 𝑏𝑟−𝑏𝑙−1
, и случай, когда 𝑙=0
, стал бы крайним, его надо было бы разбирать отдельно.
注意我们得到的美丽公式：半区间求和 [𝑙,𝑟)
 - 这 𝑏𝑟−𝑏𝑙
 。这种美妙的实现正是因为我们使用了半间隔：我们的查询以半间隔和前缀和的形式给出。如果前缀金额按以下形式计算 𝑏𝑖=𝑎0+𝑎1+…+𝑎𝑖
 ，那么公式中就会出现不愉快的情况 ±1
 ，这很容易混淆： 𝑏𝑟−𝑏𝑙−1
 ，以及当情况 𝑙=0
 ，就会变得极端，就得单独拆解了。

Префиксные минимумы и ксоры
前缀最小值和异或

Давайте зададимся вопросом: для каких операций можно использовать префиксные суммы? Не только же для сложения? Какими свойствами должна обладать операция, чтобы можно было воспользоваться префиксными суммами?
我们问问自己：前缀金额可以用于哪些操作？不只是为了加分吗？为了使用前缀和，操作必须具有哪些属性？

На самом деле, необходимо, чтобы функция, которую мы считаем на отрезке, была обратима, что равносильно тому, что должна быть возможность по двум префиксам восстановить значение на отрезке.
事实上，我们在段上计算的函数必须是可逆的，这相当于应该可以使用两个前缀来恢复段上的值。
К примеру, операция суммы обратима, потому что если мы прибавили лишнее, потом это можно вычесть. А операции минимума и максимума необратимы. Нельзя по значениям минимумов на префиксах получить значение минимума на отрезке. К примеру, если элемент на позиции 0
 в массиве самый маленький, то все префиксные минимумы будут равны этому элементу, но минимумы на каких-то отрезках совсем с ним не связаны.
例如，求和运算是可逆的，因为如果我们添加额外的内容，那么它可以被减去。并且最小和最大操作是不可逆的。从前缀上的最小值获得段上的最小值是不可能的。例如，如果一个元素位于位置 0
 是数组中最小的，那么所有前缀最小值将等于该元素，但某些段上的最小值与它根本没有联系。


![](https://espresso.codeforces.com/bf83eb5189f0de1c3fdebe9939ace228694f79cf.png)


Но кроме суммы есть и другие операции, которые являются обратимыми. Одна из самых популярных — это, пожалуй, операция «побитового исключающего или», которая еще называется «xor» и обозначается ⊕
.
但除了金额之外，还有其他操作是可逆的。最流行的一种可能是“按位异或”运算，也称为“异或”，表示为 ⊕
 。

При этом для xor'а пользоваться префиксными суммами еще удобнее. Выполнено тождество 𝑥⊕𝑥=0
 для любого числа 𝑥
, что означает, что операция xor обратна сама себе, так что формула вычисления побитового исключающего или на отрезке получается такая:
同时，对于异或，使用前缀和更加方便。身份履行 𝑥⊕𝑥=0
 对于任何数字 𝑥
 ，这意味着异或运算是其自身的逆运算，因此计算段上的按位异或的公式为：

𝑎𝑙⊕𝑎𝑙+1⊕…⊕𝑎𝑟−1=𝑏𝑟⊕𝑏𝑙

Продвинутые применения 高级应用

Давайте решим еще пару задач, в которых нам понадобятся префиксные суммы.
让我们解决另外几个需要前缀和的问题。

Задача: подотрезок нулевой суммы
问题：零和子段

Дан массив. Необходимо за 𝑂(𝑛log𝑛)
 найти любой его непустой подотрезок с нулевой суммой элементов.
给定一个数组。需要用于 𝑂(𝑛log𝑛)
 找到其元素和为零的任何非空子段。

Решение 解决方案

Как мы уже знаем, суммы на отрезках — это разности префиксных сумм. Поэтому то, что сумма на отрезке равна нулю, равносильно тому, что префиксные суммы его концов равны.
我们已经知道，段上的和是前缀和的差。因此，一段上的和等于0，就相当于其两端的前缀和相等。

Таким образом, мы свели задачу нахождения подотрезка нулевой суммы к задаче нахождения двух одинаковых элементов в массиве префиксных сумм. Для этого можно, к примеру, отсортировать массив префиксных сумм и искать совпадающие элементы среди соседних.
因此，我们将寻找零和子段的问题简化为在前缀和数组中寻找两个相同元素的问题。为此，您可以对前缀和数组进行排序，并在相邻元素中查找匹配元素。
Либо же можно воспользоваться хеш-таблицей (unordered_map в C++), и тогда асимптотика решения будет вовсе 𝑂(𝑛)
.
或者你可以使用哈希表（C++中的unordered_map），那么解的渐近行为将完全 𝑂(𝑛)
 。

Упражнение 锻炼

Даны два массива одинаковой длины. Необходимо найти такой подотрезок, чтобы сумма элементов первого массива на этом подотрезке совпадала с суммой элементов второго массива на этом подотрезке. Асимптотика 𝑂(𝑛)
.
给定两个长度相同的数组。需要找到一个子段，使得该子段上的第一数组的元素之和与该子段上的第二数组的元素之和一致。渐近学 𝑂(𝑛)
 。

Задача: кузнечик 任务：蚱蜢

Кузнечик находится в клетке с индексом 0
 и хочет попасть в клетку с индексом 𝑛
. За один прыжок кузнечик может переместиться на любое количество клеток вперед, но при этом не меньше 𝑙
 и не больше 𝑟
. Найдите, сколько существует маршрутов кузнечика. Асимптотика 𝑂(𝑛)
.
蚱蜢在一个有索引的笼子里 0
 并想要进入带有索引的单元格 𝑛
 。蚱蜢一次跳跃可以向前移动任意数量的细胞，但不能少于 𝑙
 不再有 𝑟
 。找出有多少条蚱蜢路线。渐近学 𝑂(𝑛)
 。

Решение 解决方案

Задача очень похожа на стандартную задачу о кузнечике, однако в ней прыжки имели длину 1
 и 2
, а теперь у нас количество разных прыжков неограничено, поэтому такое же решение будет работать за 𝑂(𝑛⋅(𝑟−𝑙))
, что в худшем случае будет 𝑂(𝑛2)
.
该问题与标准蚱蜢问题非常相似，但在这种情况下，跳跃有一个长度 1
 和 2
 ，现在我们有无限数量的不同跳转，因此相同的解决方案将适用于 𝑂(𝑛⋅(𝑟−𝑙))
 最坏的情况会发生什么 𝑂(𝑛2)
 。

Давайте внимательно посмотрим на формулу пересчета динамики. Количество способов попасть в клетку 𝑖
 — это сумма количеств способов попасть во все предыдущие клетки на пути кузнечика: 𝑑𝑝𝑖=𝑑𝑝𝑖−𝑟+𝑑𝑝𝑖−𝑟+1+…+𝑑𝑝𝑖−𝑙−1+𝑑𝑝𝑖−𝑙

让我们仔细看看动力学重算公式。进入笼子的方式有多种 𝑖
 是到达蚱蜢路径上所有先前单元格的方式的总和： 𝑑𝑝𝑖=𝑑𝑝𝑖−𝑟+𝑑𝑝𝑖−𝑟+1+…+𝑑𝑝𝑖−𝑙−1+𝑑𝑝𝑖−𝑙

То есть элемент массива 𝑑𝑝
 определяется через сумму отрезка элементов того же массива. Давайте идти по позициям в порядке возрастания и не только насчитывать массив 𝑑𝑝
, но и его префиксные суммы. Тогда пересчет 𝑑𝑝𝑖
 через префиксные суммы будет работать за 𝑂(1)
, а асимптотика всего алгоритма — 𝑂(𝑛)
.
也就是数组元素 𝑑𝑝
 通过同一数组的一段元素之和来确定。让我们按升序遍历位置，而不仅仅是计算数组 𝑑𝑝
 ，还有它的前缀和。然后重新叙述 𝑑𝑝𝑖
 通过前缀金额将适用于 𝑂(1)
 ，整个算法的渐近为 𝑂(𝑛)
 。

Таким образом, мы видим, что в задачах необязательно предпосчитывать массив префиксных сумм заранее, он может строиться по ходу решения задачи и одновременно с этим использоваться.
因此，我们看到，在问题中没有必要提前预先设定一个前缀和数组；它可以在问题解决时同时构建和使用。

Меняющийся массив 改变阵列

Префиксные суммы очень удобны для подсчета суммы на отрезке в том случае, если массив в ходе запросов не меняется. Потому если какой-то элемент массива поменялся, то нужно пересчитать все префиксные суммы, в которые он входит. Это очень долго!
如果数组在查询期间不发生变化，则前缀和对于计算段上的总和非常方便。因此，如果数组的某些元素发生了变化，那么您需要重新计算包含该元素的所有前缀和。这是一段很长的时间！
Если есть запросы изменения, то лучше подойдут более продвинутые структуры данных: к примеру, дерево отрезков и дерево Фенвика.
如果存在更改请求，则更高级的数据结构更适合：例如线段树和芬威克树。