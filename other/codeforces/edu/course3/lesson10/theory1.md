# Определение и построение 定义和构造

https://codeforces.com/edu/course/3/lesson/10/1

## Определение: 定义：

Префиксными суммами массива [𝑎0,𝑎1,𝑎2,…,𝑎𝑛−1] называется массив [𝑏0,𝑏1,𝑏2,…,𝑏𝑛], определяющийся следующим образом:
数组前缀和 [𝑎0,𝑎1,𝑎2,…,𝑎𝑛−1] 称为数组 [𝑏0,𝑏1,𝑏2,…,𝑏𝑛] ，定义如下：

𝑏0=0
𝑏1=𝑎0
𝑏2=𝑎0+𝑎1
𝑏3=𝑎0+𝑎1+𝑎2
…
𝑏𝑛=𝑎0+𝑎1+…+𝑎𝑛−1


## Сила полуинтервалов 半间隔的力量

Обратите внимание на то, что 𝑏𝑖  — это сумма первых 𝑖 элементов массива 𝑎. Иногда префиксные суммы определяют так, что 𝑏𝑖=𝑎0+𝑎1+…+𝑎𝑖, но этот способ неудобен на практике, в чем мы убедимся далее.
请注意 𝑏𝑖  是第一个的总和 𝑖  数组元素 𝑎  。
有时前缀和被定义为 𝑏𝑖=𝑎0+𝑎1+…+𝑎𝑖 ，但这种方法在实践中并不方便，我们稍后会看到。

На данном примере можно познакомиться с очень важной концепцией в алгоритмах: практически всегда вместо отрезков лучше использовать полуинтервалы. К примеру, в данном случае 𝑏𝑖  — это сумма элементов массива 𝑎  на полуинтервале [0,𝑖) , что на практике окажется удобнее, чем хранить в 𝑏𝑖  сумму на отрезке [0,𝑖] .
在这个例子中，您可以熟悉算法中一个非常重要的概念：使用半间隔而不是段几乎总是更好。例如，在这种情况下 𝑏𝑖 是数组元素的总和 𝑎  以半个间隔 [0,𝑖) ，在实践中这比存储在 𝑏𝑖  段上的总和 [0,𝑖]  。

Также стоит помнить о том, что длина массива 𝑏  на один больше длины массива 𝑎 .
还值得记住的是数组的长度 𝑏  比数组长度多一 𝑎  。

## Рекуррентная формула 递推公式

Формулу для 𝑏𝑖  можно записать рекурсивно:
公式为 𝑏𝑖  可以递归地写成：

𝑏0=0
𝑏𝑖+1=𝑏𝑖+𝑎𝑖  для всех 𝑖≥0

𝑏𝑖+1=𝑏𝑖+𝑎𝑖  对于每个人 𝑖≥0

Из рекуррентной формулы сразу становится ясно, как посчитать массив префиксных сумм за 𝑂(𝑛)
:
从递推公式可以立即清楚如何计算前缀和数组 𝑂(𝑛)  ：


```cpp
vector<int> findPrefixSums(vector<int>& a) {
    int n = a.size();
    vector<int> prefixSums(n + 1, 0);
    for (int i = 0; i < n; i++) {
        prefixSums[i + 1] = prefixSums[i] + a[i];
    }
    return prefixSums;
}
```


Обратите внимание, что элементы массива префиксных сумм — это суммы большого количества элементов исходного массива, поэтому будьте аккуратнее с переполнением. И вообще, на протяжении всей этой темы вы можете столкнуться с переполнением, поэтому будьте всегда начеку!
注意，前缀和数组的元素是原数组中大量元素的和，所以要小心溢出。一般来说，在整个主题中您可能会遇到溢出，因此请始终保持警惕！

Кроме того, есть встроенная в C++ функция std::partial_sum, которая как раз таки считает префиксные суммы. Пример ее работы:
另外，还有一个内置的C++函数std::partial_sum，它只计算前缀和。她的作品的一个例子：


```cpp
vector<int> arr = {1, 2, 3, 4, 5};
vector<int> prefixSums(n + 1, 0);
partial_sum(arr.begin(), arr.end(), prefixSums.begin() + 1);
for (int elem : prefixSums) {
    cout << elem << endl;
}
```

Обратите внимание, что сама функция partial_sum не оставляет нуля в начале, поэтому нам приходится делать это самим, добавляя единицу к prefixSums.begin().
请注意，partial_sum 函数本身不会在开头留下零，因此我们必须自己通过在 prefixSums.begin() 中加一来完成此操作。

Способ визуализации 可视化方法

У нас уже есть две интуиции для понимания 𝑏𝑖
: сумма первых 𝑖
 элементов исходного массива и сумма элементов исходного массива на полуинтервале [0,𝑖)
. Давайте посмотрим на еще один вариант того, как об этом можно думать. Можно представить, что элементы массива находятся в ячейках, а префиксные суммы находятся между ними — на перегородках. И содержат в себе суммы всего того, что находится перед этой перегородкой:
我们已经有两个直觉需要理解 𝑏𝑖
 ：第一个的总和 𝑖
 原数组元素与半区间上原数组元素之和 [0,𝑖)
 。让我们用另一种方式来思考这个问题。您可以想象数组的元素位于单元格中，并且前缀和位于它们之间 - 在分区上。它们包含该分区前面所有内容的总和：


 ![](https://espresso.codeforces.com/5c0aebca8a34fa29215106b650cd2a1494a169ca.png)  