/*
# P1069 [NOIP 2009 普及组] 细胞分裂

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。

Hanks 博士手里现在有 $N$ 种细胞，编号从 $1 \sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$
为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入
$M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$
值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$
均为基本数据类型可以存储的正整数。

注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$
个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$
个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。

为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$
个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。

## 输入格式

第一行，有一个正整数 $N$，代表细胞种数。

第二行，有两个正整数 $m_1,m_2$，以一个空格隔开，即表示试管的总数 $M = m_1^{m_2}$。

第三行有 $N$ 个正整数，第 $i$ 个数 $S_i$ 表示第 $i$ 种细胞经过 $1$ 秒钟可以分裂成同种细胞的个数。

## 输出格式

一个整数，表示从开始培养细胞到实验能够开始所经过的最少时间（单位为秒）。

如果无论 Hanks 博士选择哪种细胞都不能满足要求，则输出整数 $-1$。

## 输入输出样例 #1

### 输入 #1

```
1
2 1
3
```

### 输出 #1

```
-1
```

## 输入输出样例 #2

### 输入 #2

```
2
24 1
30 12
```

### 输出 #2

```
2
```

## 说明/提示

【输入输出样例 \#1 说明】

经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成
$9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。

【输入输出样例 \#2 说明】

第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$
个）。故实验最早可以在 $2$ 秒后开始。

【数据范围】

对于 $50 \%$ 的数据，有 $m_1^{m_2} \le 30000$。

对于所有的数据，有 $1 \le N \le 10000$，$1 \le m_1 \le 30000$，$1 \le m_2 \le 10000$，$1 \le S_i \le 2 \times {10}^9$。


NOIP 2009 普及组 第三题
*/

#include <bits/stdc++.h>
using namespace std;
const int N = 30000;
int isprim[N];  // 标记是否为质数
int p[N];       // 存储所有的质数
int cnt = 0;    // 存储质数的数组下标
int n, m1, m2, s;
int num1[N], num2[N];  // 分别存储对应质因数的指数
int ans = INT_MAX;     // 最小时间

// 筛选 30000 以内的所有质数
void get_prim() {
  int m = sqrt(30000);
  for (int i = 2; i <= m; i++) {
    if (isprim[i]) {
      for (int j = i * i; j <= 30000; j += i) {
        isprim[j] = 0;
      }
    }
  }

  for (int i = 2; i <= 30000; i++) {
    if (isprim[i]) {
      p[cnt++] = i;
    }
  }
}

// 对 m1 进行质因数分解
void fenjiem(int m1) {
  for (int i = 0; i < cnt && p[i] <= m1; i++) {
    while (m1 % p[i] == 0) {
      num1[p[i]] += m2;  // 每找到一个质因数，其指数就加m2
      m1 /= p[i];
    }
  }
}

// 对 s 进行质因数分解
void fenjies(int s) {
  for (int i = 0; i < cnt && p[i] <= s; i++) {
    while (s % p[i] == 0) {
      num2[p[i]]++;  // 每找到一个质因数，其指数加 1
      s /= p[i];
    }
  }
}

int main() {
  // freopen("1.in","r",stdin);
  // freopen("1.out","w",stdout);
  // 预先标记 30000 以内的所有数为质数
  memset(isprim, 1, sizeof(isprim));
  get_prim();
  // 输入 n, m1, m2
  scanf("%d%d%d", &n, &m1, &m2);
  if (m1 == 1) {  // 特殊处理
    printf("0\n");
  } else {
    memset(num1, 0, sizeof(num1));  // 每次 si 的质因数，需要清空
    fenjiem(m1);                    // 对 m1 进行质因数分解，以确定每个质因数的指数
    for (int i = 0; i < n; i++) {
      scanf("%d", &s);
      if (s == 1) continue;
      memset(num2, 0, sizeof(num2));      // 每次 si 的质因数，需要清空
      fenjies(s);                         // 对 s 进行质因数分解，以确定每个质因数的指数
      int ct = -1;                        // 表示需要的时间
      for (int i = 0; i < cnt; i++) {     // 检查对应质因数的指数是否一致
        if (num1[p[i]] && !num2[p[i]]) {  // 如果m1中有，但是s中的所有质数
          break;
        }
        // 如果有一个质因数存在，就可以开始计算了，只需要计算最大的指数
        if (num2[p[i]]) ct = max(ct, (int)(ceil(num1[p[i]] * 1.0 / num2[p[i]])));
      }
      if (ct != -1) {  // 如果得到一个可以整除的si,就更新
        ans = min(ans, ct);
      }
    }
    if (ans != INT_MAX)
      printf("%d\n", ans);
    else
      printf("-1\n");  // 如果一直都没有找到整除的si，就没有答案
    // fclose(stdin);
    // fclose(stdout);
  }
  return 0;
}
