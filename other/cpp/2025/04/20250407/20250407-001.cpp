/*
    潜水员为了潜水要使用特殊的装备。他有一个带2种气体的气缸：一个为氧气，一个为氮气。让潜水员下潜的深度需要各种的数量的氧和氮。潜水员有一定数量的气缸。每个气缸都有重量和气体容量。潜水员为了完成他的工作需要特定数量的氧和氮。他完成工作所需气缸的总重的最低限度的是多少？
    例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：
    3 36 120
    10 25 129
    5 50 250
    1 45 130
    4 20 119
    如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。
    你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。
【输入格式】
  第一行有2整数m,n（1<=m<=21,1<=n<=79）。它们表示氧，氮各自需要的量。
  第二行为整数k（1<=n<=1000）表示气缸的个数。
  此后的k行，每行包括ai，bi，ci（1<=ai<=21，1<=bi<=79，1<=ci<=800）3整数。这些各自是：第i个气缸里的氧和氮的容量及汽缸重量。
【输出格式】
  仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。
*/
#include <bits/stdc++.h>
using namespace std;
int n, v, m;
int dp[205][205][205];
int a[32], b[32], c[32];  // 每个物品的氧气需求、氮气需求、代价

int main() {
  scanf("%d%d%d", &n, &v, &m);
  for (int i = 0; i < n; i++) {
    scanf("%d%d%d", &a[i], &b[i], &c[i]);
  }
  // 初始化
  for (int i = 0; i <= n; i++) {      // 遍历每个物品
    for (int j = 0; j <= v; j++) {    // 遍历每个氧气需求
      for (int k = 0; k <= m; k++) {  // 遍历每个氮气需求
        dp[i][j][k] = 1e9; // 默认没有答案
        if (j == 0 && k == 0) {
          dp[i][j][k] = 0; // 至少需要0的氧气和氮气，代价为0
        }
      }
    }
  }

  for (int i = 1; i <= n; i++) {        // 遍历每个物品
    for (int A = 0; A <= v; A++) {      // 遍历每个氧气需求 ,这里要从0开始，因为当氧气和氮气为负数时，会更新为0的状态
      for (int B = 0; B <= m; B++) {    // 遍历每个氮气需求
        dp[i][A][B] = dp[i - 1][A][B];  // 不选当前物品
        if (A >= a[i - 1] && B >= b[i - 1]) {  // 选当前物品
          dp[i][A][B] = min(dp[i][A][B], dp[i - 1][A - a[i - 1]][B - b[i - 1]] + c[i - 1]);
        } else {
          dp[i][A][B] = min(dp[i][A][B], dp[i - 1][max(0, A - a[i - 1])][max(0, B - b[i - 1])] + c[i - 1]);
        }
      }
    }
  }

  for (int i = 1; i <= n; i++) {  // 遍历每个物品
    int A = a[i - 1];
    int B = b[i - 1];
    int C = c[i - 1];
    for (int Aj = 0; Aj <= v; Aj++) {    // 遍历每个氧气需求 ,这里要从0开始，因为当氧气和氮气为负数时，会更新为0的状态
      for (int Bk = 0; Bk <= m; Bk++) {  // 遍历每个氮气需求
        dp[i][Aj][Bk] = dp[i - 1][Aj][Bk];  // 不选当前物品
        if (Aj >= A && Bk >= B) {           // 选当前物品
          dp[i][Aj][Bk] = min(dp[i][Aj][Bk], dp[i - 1][Aj - A][Bk - B] + C);
        } else if (Aj >= A && Bk < B) {  // 选择后 氧气不够，氮气足够
          dp[i][Aj][Bk] = min(dp[i][Aj][Bk], dp[i - 1][Aj - A][0] + C);
        } else if (Bk >= B && Aj < A) {  // 选择后 氮气不够，氧气足够
          dp[i][Aj][Bk] = min(dp[i][Aj][Bk], dp[i - 1][0][Bk - B] + C);
        } else {  // 选择后 氧气和氮气都不够  (Bk < B && Aj < A)
          dp[i][Aj][Bk] = min(dp[i][Aj][Bk], dp[i - 1][0][0] + C);
        }
      }
    }
  }

  printf("%d\n", dp[n][v][m]);  // n个物品中，氧气需求为v，氮气需求为m的最小代价
  return 0;
}
/*
输入：
5 5 60
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119

输出：
249
*/